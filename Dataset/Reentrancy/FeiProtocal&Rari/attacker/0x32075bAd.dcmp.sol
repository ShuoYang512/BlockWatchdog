// Decompiled by library.dedaub.com
// 2022.12.04 11:44 UTC

// Data structures and variables inferred from the use of storage instructions
uint256 stor_2; // STORAGE[0x2]
uint256 _index; // STORAGE[0x3]
uint256[] array_7; // STORAGE[0x7]
uint256[] array_8; // STORAGE[0x8]
uint256 _update; // STORAGE[0x0] bytes 0 to 19
uint256 stor_1_0_19; // STORAGE[0x1] bytes 0 to 19
uint256 _comptroller; // STORAGE[0x4] bytes 0 to 19
uint256 _priceFeed; // STORAGE[0x5] bytes 0 to 19
uint256 _fETH; // STORAGE[0x6] bytes 0 to 19

// Events
Log(address, uint256);

function 0x34930754(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3, uint256 varg4) public nonPayable { 
    require(msg.data.length - 4 >= 160);
    require(varg0 == address(varg0));
    require(varg1 == address(varg1));
    require(varg2 == address(varg2));
    require(varg4 <= 0xffffffffffffffff);
    v0 = 0;
    require(4 + varg4 + 31 < msg.data.lengthv0, v0);
    v1 = 0x2ebc(varg4.length);
    require(!((MEM[64] + (~0x1f & v1 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v1 + 31) > 0xffffffffffffffff)), Panic(65));
    v2 = v3 = MEM[64] + 32;
    v4 = v5 = 36 + varg4;
    require(msg.data.length >= 32 + (4 + varg4 + (varg4.length << 5))v0, v0);
    while (v0 < varg4.length) {
        require(msg.data[v4] == address(msg.data[v4]));
        MEM[v2] = msg.data[v4];
        v2 += 32;
        v4 += 32;
        v0 += 1;
    }
    require(0x6162759edad730152f0df8115c698a42e666157f == msg.sender);
    require(_update, Error('no receiver'));
    _comptroller = varg0;
    require(_comptroller.code.size);
    v6, v7 = _comptroller.oracle().gas(msg.gas);
    require(v6); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
    require(v7 == address(v7));
    _priceFeed = v7;
    _fETH = varg1;
    require(varg4.length <= 0xffffffffffffffff, Panic(65));
    v8 = new uint256[](varg4.length);
    if (varg4.length) {
        CALLDATACOPY(v8.data, msg.data.length, varg4.length << 5);
    }
    require(varg4.length <= 0xffffffffffffffff, Panic(65));
    v9 = new uint256[](varg4.length);
    if (varg4.length) {
        CALLDATACOPY(v9.data, msg.data.length, varg4.length << 5);
    }
    v10 = v11 = 0;
    while (v10 < varg4.length) {
        if (v10 < varg4.length) {
            break;
        }
        require(v10 < varg4.length, Panic(50));
        if (v10 < v8.length) {
            break;
        }
        require(v10 < v8.length, Panic(50));
        v8[v10] = address(MEM[32 + (v10 << 5) + MEM[64]]);
        require(v10 < varg4.length, Panic(50));
        require((address(MEM[32 + (v10 << 5) + MEM[64]])).code.size);
        v12, v13 = address(MEM[32 + (v10 << 5) + MEM[64]]).underlying().gas(msg.gas);
        require(v12); // checks call status, propagates error data on error
        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
        require(v13 == address(v13));
        require(v10 < v9.length, Panic(50));
        v9[v10] = address(v13);
        v10 = 0x2f8a(v10);
    }
    v14 = v15 = v8.data;
    array_7.length = v8.length;
    if (v8.length) {
        while (v15 + (v8.length << 5) > v14) {
            STORAGE[v16] = address(MEM[v14]) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v16];
            v14 = v14 + 32;
            v16 = v16 + 1;
        }
    }
    while (v17 + array_7.length > v16) {
        STORAGE[v16] = 0;
        v16 += 1;
    }
    v18 = v19 = v9.data;
    array_8.length = v9.length;
    if (v9.length) {
        while (v19 + (v9.length << 5) > v18) {
            STORAGE[v20] = address(MEM[v18]) | ~0xffffffffffffffffffffffffffffffffffffffff & STORAGE[v20];
            v18 = v18 + 32;
            v20 = v20 + 1;
        }
    }
    while (v21 + array_8.length > v20) {
        STORAGE[v20] = 0;
        v20 += 1;
    }
    stor_1_0_19 = varg2;
    stor_2 = varg3;
    CALLDATACOPY(v22.data, msg.data.length, 64);
    CALLDATACOPY(v23.data, msg.data.length, 64);
    if (address(varg2) < 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2) {
        require(0 < v22.length, Panic(50));
        MEM[v22.data] = address(varg2);
        require(1 < v22.length, Panic(50));
        require(0 < v23.length, Panic(50));
        MEM[v23.data] = varg3;
        require(1 < v23.length, Panic(50));
    } else {
        require(0 < v22.length, Panic(50));
        require(1 < v22.length, Panic(50));
        MEM[0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2c02aaa39b223fe8d0a0e5c4f27ead9083c756cc62] = address(varg2);
        require(0 < v23.length, Panic(50));
        require(1 < v23.length, Panic(50));
        MEM[0xa968163f0a57b400000a968163f0a57b4000005c38449e00000000000000000000000000000000000000000000000000000040] = varg3;
    }
    v24 = v25 = 0;
    v26 = new array[](v22.length);
    v27 = v28 = 0;
    v29 = v30 = v26.data;
    v31 = v32 = v22.data;
    while (v27 < v22.length) {
        MEM[v29] = address(MEM[v31]);
        v29 += 32;
        v31 += 32;
        v27 += 1;
    }
    v29 = new array[](v23.length);
    v33 = v34 = v23.data;
    v35 = v36 = v29.data;
    while (v24 < v23.length) {
        MEM[v35] = MEM[v33];
        v33 += 32;
        v35 += 32;
        v24 += 1;
    }
    v35 = new array[](v25);
    require(0xba12222222228d8ba445958a75a0704d566bf2c8.code.size);
    v37 = 0xba12222222228d8ba445958a75a0704d566bf2c8.flashLoan(address(this), v26, v29, v35).gas(msg.gas);
    require(v37); // checks call status, propagates error data on error
}

function 0x349b4736(uint256 varg0, uint256 varg1, uint256 varg2) public nonPayable { 
    require(msg.data.length - 4 >= 96);
    require(varg0 == address(varg0));
    require(varg1 == address(varg1));
    require(varg2 == address(varg2));
    MEM[(32 + MEM[64]) len 6844] = 0x60a06040523480156200001157600080fd5b5060405162001abc38038062001abc833981016040819052620000349162000097565b60609290921b6001600160601b031916608052600080546001600160a01b03199081166001600160a01b03938416179091556001805490911691909216179055620000e0565b80516001600160a01b03811681146200009257600080fd5b919050565b600080600060608486031215620000ac578283fd5b620000b7846200007a565b9250620000c7602085016200007a565b9150620000d7604085016200007a565b90509250925092565b60805160601c61199362000129600039600081816103190152818161073101528181610adb01528181610b0801528181610c1c01528181610f040152610fa001526119936000f3fe6080604052600436106100955760003560e01c8063ad5c464811610059578063ad5c464814610277578063bd5b853b1461028c578063be6002c2146102ac578063c5ebeaec146102d9578063cc14d688146102f9576101e8565b80631249c58b146101ed5780632f4350c2146102025780635fe3b567146102175780638da5cb5b14610242578063a9059cbb14610257576101e8565b366101e8573373c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2146101e6576000600280548060200260200160405190810160405280929190818152602001828054801561010d57602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116100ef575b5050505050905060005b81518110156101e3576000805483516001600160a01b039091169063ede4edd09085908590811061015857634e487b7160e01b600052603260045260246000fd5b60200260200101516040518263ffffffff1660e01b815260040161017c9190611647565b602060405180830381600087803b15801561019657600080fd5b505af11580156101aa573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ce9190611613565b508190506101db81611908565b915050610117565b50505b005b600080fd5b3480156101f957600080fd5b506101e661030e565b34801561020e57600080fd5b506101e6610726565b34801561022357600080fd5b5061022c610aca565b6040516102399190611647565b60405180910390f35b34801561024e57600080fd5b5061022c610ad9565b34801561026357600080fd5b506101e661027236600461148e565b610afd565b34801561028357600080fd5b5061022c610bf9565b34801561029857600080fd5b506101e66102a73660046114b9565b610c11565b3480156102b857600080fd5b506102cc6102c73660046113ec565b610ef7565b60405161023991906116db565b3480156102e557600080fd5b506101e66102f43660046115fb565b610f95565b34801561030557600080fd5b5061022c61104c565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461034357600080fd5b6000600280548060200260200160405190810160405280929190818152602001828054801561039b57602002820191906000526020600020905b81546001600160a01b0316815260019091019060200180831161037d575b50505050509050600060038054806020026020016040519081016040528092919081815260200182805480156103fa57602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116103dc575b505050505090506000825167ffffffffffffffff81111561042b57634e487b7160e01b600052604160045260246000fd5b604051908082528060200260200182016040528015610454578160200160208202803683370190505b50905060005b835181101561070c57600083828151811061048557634e487b7160e01b600052603260045260246000fd5b602002602001015190506104d68583815181106104b257634e487b7160e01b600052603260045260246000fd5b6020026020010151600019836001600160a01b031661105b9092919063ffffffff16565b6040516370a0823160e01b81526000906001600160a01b038316906370a0823190610505903090600401611647565b60206040518083038186803b15801561051d57600080fd5b505afa158015610531573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105559190611613565b905085838151811061057757634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b031663a6afed956040518163ffffffff1660e01b8152600401602060405180830381600087803b1580156105b957600080fd5b505af11580156105cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105f19190611613565b5080156106f757600086848151811061061a57634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b031663a0712d68836040518263ffffffff1660e01b815260040161064d919061187e565b602060405180830381600087803b15801561066757600080fd5b505af115801561067b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069f9190611613565b905080156106c85760405162461bcd60e51b81526004016106bf9061185b565b60405180910390fd5b818585815181106106e957634e487b7160e01b600052603260045260246000fd5b602002602001018181525050505b5050808061070490611908565b91505061045a565b50805161072090600490602084019061131b565b50505050565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461075b57600080fd5b600060028054806020026020016040519081016040528092919081815260200182805480156107b357602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610795575b505050505090506000600380548060200260200160405190810160405280929190818152602001828054801561081257602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116107f4575b505050505090506000600480548060200260200160405190810160405280929190818152602001828054801561086757602002820191906000526020600020905b815481526020019060010190808311610853575b5050505050905060005b835181101561072057600084828151811061089c57634e487b7160e01b600052603260045260246000fd5b6020026020010151905060008483815181106108c857634e487b7160e01b600052603260045260246000fd5b602002602001015190506108f282600019846001600160a01b031661105b9092919063ffffffff16565b600084848151811061091457634e487b7160e01b600052603260045260246000fd5b602002602001015111156109eb576000826001600160a01b031663852a12e386868151811061095357634e487b7160e01b600052603260045260246000fd5b60200260200101516040518263ffffffff1660e01b8152600401610977919061187e565b602060405180830381600087803b15801561099157600080fd5b505af11580156109a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109c99190611613565b905080156109e95760405162461bcd60e51b81526004016106bf9061175f565b505b6040516370a0823160e01b81526000906001600160a01b038316906370a0823190610a1a903090600401611647565b60206040518083038186803b158015610a3257600080fd5b505afa158015610a46573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a6a9190611613565b9050610a806001600160a01b0383163383611155565b4715610ab45760405133904780156108fc02916000818181858888f19350505050158015610ab2573d6000803e3d6000fd5b505b5050508080610ac290611908565b915050610871565b6000546001600160a01b031681565b7f000000000000000000000000000000000000000000000000000000000000000081565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610b3257600080fd5b6001600160a01b038216610b7357604051339082156108fc029083906000818181858888f19350505050158015610b6d573d6000803e3d6000fd5b50610bf5565b60405163a9059cbb60e01b81526001600160a01b0383169063a9059cbb90610ba19033908590600401611675565b602060405180830381600087803b158015610bbb57600080fd5b505af1158015610bcf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bf391906115db565b505b5050565b73c02aaa39b223fe8d0a0e5c4f27ead9083c756cc281565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610c4657600080fd5b6000815167ffffffffffffffff811115610c7057634e487b7160e01b600052604160045260246000fd5b604051908082528060200260200182016040528015610c99578160200160208202803683370190505b5090506000825167ffffffffffffffff811115610cc657634e487b7160e01b600052604160045260246000fd5b604051908082528060200260200182016040528015610cef578160200160208202803683370190505b50905060005b8351811015610e4857838181518110610d1e57634e487b7160e01b600052603260045260246000fd5b6020026020010151838281518110610d4657634e487b7160e01b600052603260045260246000fd5b60200260200101906001600160a01b031690816001600160a01b031681525050838181518110610d8657634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b0316636f307dc36040518163ffffffff1660e01b815260040160206040518083038186803b158015610dc657600080fd5b505afa158015610dda573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dfe91906113d0565b828281518110610e1e57634e487b7160e01b600052603260045260246000fd5b6001600160a01b039092166020928302919091019091015280610e4081611908565b915050610cf5565b508151610e5c906002906020850190611366565b508051610e70906003906020840190611366565b50600054604051631853304760e31b81526001600160a01b039091169063c299823890610ea190869060040161168e565b600060405180830381600087803b158015610ebb57600080fd5b505af1158015610ecf573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526107209190810190611557565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610f2e57600080fd5b6000836001600160a01b031683604051610f48919061162b565b6000604051808303816000865af19150503d8060008114610f85576040519150601f19603f3d011682016040523d82523d6000602084013e610f8a565b606091505b509095945050505050565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610fca57600080fd5b60015460405163317afabb60e21b81526001600160a01b039091169063c5ebeaec90610ffa90849060040161187e565b602060405180830381600087803b15801561101457600080fd5b505af1158015611028573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bf59190611613565b6001546001600160a01b031681565b8015806110e35750604051636eb1769f60e11b81526001600160a01b0384169063dd62ed3e90611091903090869060040161165b565b60206040518083038186803b1580156110a957600080fd5b505afa1580156110bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110e19190611613565b155b6110ff5760405162461bcd60e51b81526004016106bf90611805565b610bf38363095ea7b360e01b848460405160240161111e929190611675565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611174565b610bf38363a9059cbb60e01b848460405160240161111e929190611675565b60006111c9826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166112039092919063ffffffff16565b805190915015610bf357808060200190518101906111e791906115db565b610bf35760405162461bcd60e51b81526004016106bf906117bb565b6060611212848460008561121c565b90505b9392505050565b60608247101561123e5760405162461bcd60e51b81526004016106bf90611719565b611247856112dc565b6112635760405162461bcd60e51b81526004016106bf90611784565b600080866001600160a01b0316858760405161127f919061162b565b60006040518083038185875af1925050503d80600081146112bc576040519150601f19603f3d011682016040523d82523d6000602084013e6112c1565b606091505b50915091506112d18282866112e2565b979650505050505050565b3b151590565b606083156112f1575081611215565b8251156113015782518084602001fd5b8160405162461bcd60e51b81526004016106bf91906116e6565b828054828255906000526020600020908101928215611356579160200282015b8281111561135657825182559160200191906001019061133b565b506113629291506113bb565b5090565b828054828255906000526020600020908101928215611356579160200282015b8281111561135657825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190611386565b5b8082111561136257600081556001016113bc565b6000602082840312156113e1578081fd5b815161121581611945565b600080604083850312156113fe578081fd5b823561140981611945565b915060208381013567ffffffffffffffff80821115611426578384fd5b818601915086601f830112611439578384fd5b81358181111561144b5761144b61192f565b61145d601f8201601f19168501611887565b91508082528784828501011115611472578485fd5b8084840185840137810190920192909252919491935090915050565b600080604083850312156114a0578182fd5b82356114ab81611945565b946020939093013593505050565b600060208083850312156114cb578182fd5b823567ffffffffffffffff8111156114e1578283fd5b8301601f810185136114f1578283fd5b80356115046114ff826118b8565b611887565b8181528381019083850185840285018601891015611520578687fd5b8694505b8385101561154b57803561153781611945565b835260019490940193918501918501611524565b50979650505050505050565b60006020808385031215611569578182fd5b825167ffffffffffffffff81111561157f578283fd5b8301601f8101851361158f578283fd5b805161159d6114ff826118b8565b81815283810190838501858402850186018910156115b9578687fd5b8694505b8385101561154b5780518352600194909401939185019185016115bd565b6000602082840312156115ec578081fd5b81518015158114611215578182fd5b60006020828403121561160c578081fd5b5035919050565b600060208284031215611624578081fd5b5051919050565b6000825161163d8184602087016118dc565b9190910192915050565b6001600160a01b0391909116815260200190565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b03929092168252602082015260400190565b6020808252825182820181905260009190848201906040850190845b818110156116cf5783516001600160a01b0316835292840192918401916001016116aa565b50909695505050505050565b901515815260200190565b60006020825282518060208401526117058160408501602087016118dc565b601f01601f19169190910160400192915050565b60208082526026908201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6040820152651c8818d85b1b60d21b606082015260800190565b6020808252600b908201526a1c995919595b4819985a5b60aa1b604082015260600190565b6020808252601d908201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604082015260600190565b6020808252602a908201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6040820152691bdd081cdd58d8d9595960b21b606082015260800190565b60208082526036908201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60408201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b606082015260800190565b6020808252600990820152681b5a5b9d0819985a5b60ba1b604082015260600190565b90815260200190565b604051601f8201601f1916810167ffffffffffffffff811182821017156118b0576118b061192f565b604052919050565b600067ffffffffffffffff8211156118d2576118d261192f565b5060209081020190565b60005b838110156118f75781810151838201526020016118df565b838111156107205750506000910152565b600060001982141561192857634e487b7160e01b81526011600452602481fd5b5060010190565b634e487b7160e01b600052604160045260246000fd5b6001600160a01b038116811461195a57600080fd5b5056fea26469706673582212202d5196c0488c5ce698d76e2a3bf0488acbfc83ed44c3093809d810c6438f1d5064736f6c63430008010033;
    MEM[32 + MEM[64]] = address(varg0);
    MEM[32 + MEM[64] + 32] = address(varg1);
    MEM[32 + MEM[64] + 64] = address(varg2);
    v0 = v1 = 0;
    while (v0 < 6844) {
        MEM[v0 + (160 + MEM[64])] = MEM[v0 + (MEM[64] + 32)];
        v0 += 32;
    }
    if (v0 > 6844) {
        MEM[7004 + MEM[64]] = 0;
        goto 0x2c40B0x170;
    }
    v2 = v3 = 0;
    while (v2 < 96) {
        MEM[v2 + (160 + MEM[64] + 6844)] = MEM[v2 + (MEM[64] + 32)];
        v2 += 32;
    }
    if (v2 > 96) {
        MEM[96 + (160 + MEM[64] + 6844)] = 0;
        goto 0x2c56B0x170;
    }
    MEM[64] = 96 + (160 + MEM[64] + 6844);
    v4 = new array[](96 + (160 + MEM[64] + 6844) - MEM[64] - 32);
    v5 = v6 = 0;
    while (v5 < 96 + (160 + MEM[64] + 6844) - MEM[64] - 32) {
        v4[v5] = MEM[v5 + (MEM[64] + 32)];
        v5 += 32;
    }
    if (v5 > 96 + (160 + MEM[64] + 6844) - MEM[64] - 32) {
        v4[96 + (160 + MEM[64] + 6844) - MEM[64] - 32] = 0;
        goto 0x2bd8B0x176;
    }
    return v4;
}

function comptroller() public nonPayable { 
    return _comptroller;
}

function priceFeed() public nonPayable { 
    return _priceFeed;
}

function exec(address varg0, bytes varg1) public nonPayable { 
    require(msg.data.length - 4 >= 64);
    require(varg0 == varg0);
    require(varg1 <= 0xffffffffffffffff);
    require(4 + varg1 + 31 < msg.data.length);
    require(varg1.length <= 0xffffffffffffffff, Panic(65));
    v0 = new bytes[](varg1.length);
    require(!((v0 + (~0x1f & 32 + (~0x1f & varg1.length + 31) + 31) < v0) | (v0 + (~0x1f & 32 + (~0x1f & varg1.length + 31) + 31) > 0xffffffffffffffff)), Panic(65));
    require(4 + varg1 + varg1.length + 32 <= msg.data.length);
    CALLDATACOPY(v0.data, 4 + varg1 + 32, varg1.length);
    v0[varg1.length] = 0;
    require(0x6162759edad730152f0df8115c698a42e666157f == msg.sender);
    v1 = v2 = 0;
    while (v1 < v0.length) {
        MEM[v1 + v3.data] = v0[v1];
        v1 += 32;
    }
    if (v1 > v0.length) {
        MEM[v0.length + v3.data] = 0;
        goto 0x2c22B0xc4aB0x1e3;
    }
    v4, v5 = varg0.call(v3.data).gas(msg.gas);
    if (RETURNDATASIZE() != 0) {
        v6 = new bytes[](RETURNDATASIZE());
        RETURNDATACOPY(v6.data, 0, RETURNDATASIZE());
    }
    return v4;
}

function fETH() public nonPayable { 
    return _fETH;
}

function receiveFlashLoan(address[] varg0, uint256[] varg1, uint256[] varg2, bytes varg3) public nonPayable { 
    require(msg.data.length - 4 >= 128);
    require(varg0 <= 0xffffffffffffffff);
    v0 = 0;
    require(4 + varg0 + 31 < msg.data.lengthv0, v0);
    v1 = 0x2ebc(varg0.length);
    require(!((MEM[64] + (~0x1f & v1 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v1 + 31) > 0xffffffffffffffff)), Panic(65));
    MEM[64] = MEM[64] + (~0x1f & v1 + 31);
    MEM[MEM[64]] = varg0.length;
    v2 = v3 = MEM[64] + 32;
    v4 = v5 = 36 + varg0;
    require(msg.data.length >= 32 + (4 + varg0 + (varg0.length << 5))v0, v0);
    while (v0 < varg0.length) {
        require(msg.data[v4] == address(msg.data[v4]));
        MEM[v2] = msg.data[v4];
        v2 += 32;
        v4 += 32;
        v0 += 1;
    }
    require(varg1 <= 0xffffffffffffffff);
    v6 = v7 = 0;
    require(4 + varg1 + 31 < msg.data.lengthv7, v7);
    v8 = 0x2ebc(varg1.length);
    require(!((MEM[64] + (~0x1f & v8 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v8 + 31) > 0xffffffffffffffff)), Panic(65));
    MEM[64] = MEM[64] + (~0x1f & v8 + 31);
    MEM[MEM[64]] = varg1.length;
    v9 = v10 = MEM[64] + 32;
    v11 = v12 = 36 + varg1;
    require(msg.data.length >= 32 + (4 + varg1 + (varg1.length << 5))v7, v7);
    while (v6 < varg1.length) {
        MEM[v9] = msg.data[v11];
        v9 += 32;
        v11 += 32;
        v6 += 1;
    }
    require(varg2 <= 0xffffffffffffffff);
    v13 = v14 = 0;
    require(4 + varg2 + 31 < msg.data.lengthv14, v14);
    v15 = 0x2ebc(varg2.length);
    require(!((MEM[64] + (~0x1f & v15 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v15 + 31) > 0xffffffffffffffff)), Panic(65));
    MEM[64] = MEM[64] + (~0x1f & v15 + 31);
    MEM[MEM[64]] = varg2.length;
    v16 = v17 = MEM[64] + 32;
    v18 = v19 = 36 + varg2;
    require(msg.data.length >= 32 + (4 + varg2 + (varg2.length << 5))v14, v14);
    while (v13 < varg2.length) {
        MEM[v16] = msg.data[v18];
        v16 += 32;
        v18 += 32;
        v13 += 1;
    }
    require(varg3 <= 0xffffffffffffffff);
    require(4 + varg3 + 31 < msg.data.length);
    require(varg3.length <= 0xffffffffffffffff, Panic(65));
    v20 = new bytes[](varg3.length);
    require(!((v20 + (~0x1f & 32 + (~0x1f & varg3.length + 31) + 31) < v20) | (v20 + (~0x1f & 32 + (~0x1f & varg3.length + 31) + 31) > 0xffffffffffffffff)), Panic(65));
    require(4 + varg3 + varg3.length + 32 <= msg.data.length);
    CALLDATACOPY(v20.data, 4 + varg3 + 32, varg3.length);
    v20[varg3.length] = 0;
    v21, v22, v23, v24 = 0xcc4(v20, MEM[64], MEM[64], MEM[64]);
}

function 0x24e6() private { 
    MEM[(32 + MEM[64]) len 6844] = 0x60a06040523480156200001157600080fd5b5060405162001abc38038062001abc833981016040819052620000349162000097565b60609290921b6001600160601b031916608052600080546001600160a01b03199081166001600160a01b03938416179091556001805490911691909216179055620000e0565b80516001600160a01b03811681146200009257600080fd5b919050565b600080600060608486031215620000ac578283fd5b620000b7846200007a565b9250620000c7602085016200007a565b9150620000d7604085016200007a565b90509250925092565b60805160601c61199362000129600039600081816103190152818161073101528181610adb01528181610b0801528181610c1c01528181610f040152610fa001526119936000f3fe6080604052600436106100955760003560e01c8063ad5c464811610059578063ad5c464814610277578063bd5b853b1461028c578063be6002c2146102ac578063c5ebeaec146102d9578063cc14d688146102f9576101e8565b80631249c58b146101ed5780632f4350c2146102025780635fe3b567146102175780638da5cb5b14610242578063a9059cbb14610257576101e8565b366101e8573373c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2146101e6576000600280548060200260200160405190810160405280929190818152602001828054801561010d57602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116100ef575b5050505050905060005b81518110156101e3576000805483516001600160a01b039091169063ede4edd09085908590811061015857634e487b7160e01b600052603260045260246000fd5b60200260200101516040518263ffffffff1660e01b815260040161017c9190611647565b602060405180830381600087803b15801561019657600080fd5b505af11580156101aa573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906101ce9190611613565b508190506101db81611908565b915050610117565b50505b005b600080fd5b3480156101f957600080fd5b506101e661030e565b34801561020e57600080fd5b506101e6610726565b34801561022357600080fd5b5061022c610aca565b6040516102399190611647565b60405180910390f35b34801561024e57600080fd5b5061022c610ad9565b34801561026357600080fd5b506101e661027236600461148e565b610afd565b34801561028357600080fd5b5061022c610bf9565b34801561029857600080fd5b506101e66102a73660046114b9565b610c11565b3480156102b857600080fd5b506102cc6102c73660046113ec565b610ef7565b60405161023991906116db565b3480156102e557600080fd5b506101e66102f43660046115fb565b610f95565b34801561030557600080fd5b5061022c61104c565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461034357600080fd5b6000600280548060200260200160405190810160405280929190818152602001828054801561039b57602002820191906000526020600020905b81546001600160a01b0316815260019091019060200180831161037d575b50505050509050600060038054806020026020016040519081016040528092919081815260200182805480156103fa57602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116103dc575b505050505090506000825167ffffffffffffffff81111561042b57634e487b7160e01b600052604160045260246000fd5b604051908082528060200260200182016040528015610454578160200160208202803683370190505b50905060005b835181101561070c57600083828151811061048557634e487b7160e01b600052603260045260246000fd5b602002602001015190506104d68583815181106104b257634e487b7160e01b600052603260045260246000fd5b6020026020010151600019836001600160a01b031661105b9092919063ffffffff16565b6040516370a0823160e01b81526000906001600160a01b038316906370a0823190610505903090600401611647565b60206040518083038186803b15801561051d57600080fd5b505afa158015610531573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105559190611613565b905085838151811061057757634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b031663a6afed956040518163ffffffff1660e01b8152600401602060405180830381600087803b1580156105b957600080fd5b505af11580156105cd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105f19190611613565b5080156106f757600086848151811061061a57634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b031663a0712d68836040518263ffffffff1660e01b815260040161064d919061187e565b602060405180830381600087803b15801561066757600080fd5b505af115801561067b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061069f9190611613565b905080156106c85760405162461bcd60e51b81526004016106bf9061185b565b60405180910390fd5b818585815181106106e957634e487b7160e01b600052603260045260246000fd5b602002602001018181525050505b5050808061070490611908565b91505061045a565b50805161072090600490602084019061131b565b50505050565b336001600160a01b037f0000000000000000000000000000000000000000000000000000000000000000161461075b57600080fd5b600060028054806020026020016040519081016040528092919081815260200182805480156107b357602002820191906000526020600020905b81546001600160a01b03168152600190910190602001808311610795575b505050505090506000600380548060200260200160405190810160405280929190818152602001828054801561081257602002820191906000526020600020905b81546001600160a01b031681526001909101906020018083116107f4575b505050505090506000600480548060200260200160405190810160405280929190818152602001828054801561086757602002820191906000526020600020905b815481526020019060010190808311610853575b5050505050905060005b835181101561072057600084828151811061089c57634e487b7160e01b600052603260045260246000fd5b6020026020010151905060008483815181106108c857634e487b7160e01b600052603260045260246000fd5b602002602001015190506108f282600019846001600160a01b031661105b9092919063ffffffff16565b600084848151811061091457634e487b7160e01b600052603260045260246000fd5b602002602001015111156109eb576000826001600160a01b031663852a12e386868151811061095357634e487b7160e01b600052603260045260246000fd5b60200260200101516040518263ffffffff1660e01b8152600401610977919061187e565b602060405180830381600087803b15801561099157600080fd5b505af11580156109a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906109c99190611613565b905080156109e95760405162461bcd60e51b81526004016106bf9061175f565b505b6040516370a0823160e01b81526000906001600160a01b038316906370a0823190610a1a903090600401611647565b60206040518083038186803b158015610a3257600080fd5b505afa158015610a46573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610a6a9190611613565b9050610a806001600160a01b0383163383611155565b4715610ab45760405133904780156108fc02916000818181858888f19350505050158015610ab2573d6000803e3d6000fd5b505b5050508080610ac290611908565b915050610871565b6000546001600160a01b031681565b7f000000000000000000000000000000000000000000000000000000000000000081565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610b3257600080fd5b6001600160a01b038216610b7357604051339082156108fc029083906000818181858888f19350505050158015610b6d573d6000803e3d6000fd5b50610bf5565b60405163a9059cbb60e01b81526001600160a01b0383169063a9059cbb90610ba19033908590600401611675565b602060405180830381600087803b158015610bbb57600080fd5b505af1158015610bcf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bf391906115db565b505b5050565b73c02aaa39b223fe8d0a0e5c4f27ead9083c756cc281565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610c4657600080fd5b6000815167ffffffffffffffff811115610c7057634e487b7160e01b600052604160045260246000fd5b604051908082528060200260200182016040528015610c99578160200160208202803683370190505b5090506000825167ffffffffffffffff811115610cc657634e487b7160e01b600052604160045260246000fd5b604051908082528060200260200182016040528015610cef578160200160208202803683370190505b50905060005b8351811015610e4857838181518110610d1e57634e487b7160e01b600052603260045260246000fd5b6020026020010151838281518110610d4657634e487b7160e01b600052603260045260246000fd5b60200260200101906001600160a01b031690816001600160a01b031681525050838181518110610d8657634e487b7160e01b600052603260045260246000fd5b60200260200101516001600160a01b0316636f307dc36040518163ffffffff1660e01b815260040160206040518083038186803b158015610dc657600080fd5b505afa158015610dda573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610dfe91906113d0565b828281518110610e1e57634e487b7160e01b600052603260045260246000fd5b6001600160a01b039092166020928302919091019091015280610e4081611908565b915050610cf5565b508151610e5c906002906020850190611366565b508051610e70906003906020840190611366565b50600054604051631853304760e31b81526001600160a01b039091169063c299823890610ea190869060040161168e565b600060405180830381600087803b158015610ebb57600080fd5b505af1158015610ecf573d6000803e3d6000fd5b505050506040513d6000823e601f3d908101601f191682016040526107209190810190611557565b6000336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610f2e57600080fd5b6000836001600160a01b031683604051610f48919061162b565b6000604051808303816000865af19150503d8060008114610f85576040519150601f19603f3d011682016040523d82523d6000602084013e610f8a565b606091505b509095945050505050565b336001600160a01b037f00000000000000000000000000000000000000000000000000000000000000001614610fca57600080fd5b60015460405163317afabb60e21b81526001600160a01b039091169063c5ebeaec90610ffa90849060040161187e565b602060405180830381600087803b15801561101457600080fd5b505af1158015611028573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610bf59190611613565b6001546001600160a01b031681565b8015806110e35750604051636eb1769f60e11b81526001600160a01b0384169063dd62ed3e90611091903090869060040161165b565b60206040518083038186803b1580156110a957600080fd5b505afa1580156110bd573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110e19190611613565b155b6110ff5760405162461bcd60e51b81526004016106bf90611805565b610bf38363095ea7b360e01b848460405160240161111e929190611675565b60408051601f198184030181529190526020810180516001600160e01b03166001600160e01b031990931692909217909152611174565b610bf38363a9059cbb60e01b848460405160240161111e929190611675565b60006111c9826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166112039092919063ffffffff16565b805190915015610bf357808060200190518101906111e791906115db565b610bf35760405162461bcd60e51b81526004016106bf906117bb565b6060611212848460008561121c565b90505b9392505050565b60608247101561123e5760405162461bcd60e51b81526004016106bf90611719565b611247856112dc565b6112635760405162461bcd60e51b81526004016106bf90611784565b600080866001600160a01b0316858760405161127f919061162b565b60006040518083038185875af1925050503d80600081146112bc576040519150601f19603f3d011682016040523d82523d6000602084013e6112c1565b606091505b50915091506112d18282866112e2565b979650505050505050565b3b151590565b606083156112f1575081611215565b8251156113015782518084602001fd5b8160405162461bcd60e51b81526004016106bf91906116e6565b828054828255906000526020600020908101928215611356579160200282015b8281111561135657825182559160200191906001019061133b565b506113629291506113bb565b5090565b828054828255906000526020600020908101928215611356579160200282015b8281111561135657825182546001600160a01b0319166001600160a01b03909116178255602090920191600190910190611386565b5b8082111561136257600081556001016113bc565b6000602082840312156113e1578081fd5b815161121581611945565b600080604083850312156113fe578081fd5b823561140981611945565b915060208381013567ffffffffffffffff80821115611426578384fd5b818601915086601f830112611439578384fd5b81358181111561144b5761144b61192f565b61145d601f8201601f19168501611887565b91508082528784828501011115611472578485fd5b8084840185840137810190920192909252919491935090915050565b600080604083850312156114a0578182fd5b82356114ab81611945565b946020939093013593505050565b600060208083850312156114cb578182fd5b823567ffffffffffffffff8111156114e1578283fd5b8301601f810185136114f1578283fd5b80356115046114ff826118b8565b611887565b8181528381019083850185840285018601891015611520578687fd5b8694505b8385101561154b57803561153781611945565b835260019490940193918501918501611524565b50979650505050505050565b60006020808385031215611569578182fd5b825167ffffffffffffffff81111561157f578283fd5b8301601f8101851361158f578283fd5b805161159d6114ff826118b8565b81815283810190838501858402850186018910156115b9578687fd5b8694505b8385101561154b5780518352600194909401939185019185016115bd565b6000602082840312156115ec578081fd5b81518015158114611215578182fd5b60006020828403121561160c578081fd5b5035919050565b600060208284031215611624578081fd5b5051919050565b6000825161163d8184602087016118dc565b9190910192915050565b6001600160a01b0391909116815260200190565b6001600160a01b0392831681529116602082015260400190565b6001600160a01b03929092168252602082015260400190565b6020808252825182820181905260009190848201906040850190845b818110156116cf5783516001600160a01b0316835292840192918401916001016116aa565b50909695505050505050565b901515815260200190565b60006020825282518060208401526117058160408501602087016118dc565b601f01601f19169190910160400192915050565b60208082526026908201527f416464726573733a20696e73756666696369656e742062616c616e636520666f6040820152651c8818d85b1b60d21b606082015260800190565b6020808252600b908201526a1c995919595b4819985a5b60aa1b604082015260600190565b6020808252601d908201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604082015260600190565b6020808252602a908201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6040820152691bdd081cdd58d8d9595960b21b606082015260800190565b60208082526036908201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60408201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b606082015260800190565b6020808252600990820152681b5a5b9d0819985a5b60ba1b604082015260600190565b90815260200190565b604051601f8201601f1916810167ffffffffffffffff811182821017156118b0576118b061192f565b604052919050565b600067ffffffffffffffff8211156118d2576118d261192f565b5060209081020190565b60005b838110156118f75781810151838201526020016118df565b838111156107205750506000910152565b600060001982141561192857634e487b7160e01b81526011600452602481fd5b5060010190565b634e487b7160e01b600052604160045260246000fd5b6001600160a01b038116811461195a57600080fd5b5056fea26469706673582212202d5196c0488c5ce698d76e2a3bf0488acbfc83ed44c3093809d810c6438f1d5064736f6c63430008010033;
    MEM[32 + MEM[64]] = address(this);
    MEM[32 + MEM[64] + 32] = _comptroller;
    MEM[32 + MEM[64] + 64] = _fETH;
    v0 = v1 = 0;
    while (v0 < 6844) {
        MEM[v0 + (160 + MEM[64])] = MEM[v0 + (MEM[64] + 32)];
        v0 += 32;
    }
    if (v0 > 6844) {
        MEM[7004 + MEM[64]] = 0;
        goto 0x2c40B0x24e6;
    }
    v2 = v3 = 0;
    while (v2 < 96) {
        MEM[v2 + (160 + MEM[64] + 6844)] = MEM[v2 + (MEM[64] + 32)];
        v2 += 32;
    }
    if (v2 > 96) {
        MEM[96 + (160 + MEM[64] + 6844)] = 0;
        goto 0x2c56B0x24e6;
    }
    MEM[64] = 96 + (160 + MEM[64] + 6844);
    require(1 <= ~_index, Panic(17));
    _index += 1;
    return CREATE2(0, MEM[64] + 32, 96 + (160 + MEM[64] + 6844) - MEM[64] - 32, keccak256(~0xffffffffffffffffffffffff & msg.sender << 96, _index));
}

function 0x2ebc(uint256 varg0) private { 
    require(varg0 <= 0xffffffffffffffff, Panic(65));
    return (varg0 << 5) + 32;
}

function _SafeMul(uint256 varg0, uint256 varg1) private { 
    require(!(varg0 & (varg1 > ~0 / varg0)), Panic(17));
    return varg0 * varg1;
}

function _SafeSub(uint256 varg0, uint256 varg1) private { 
    require(varg0 >= varg1, Panic(17));
    return varg0 - varg1;
}

function 0x2f8a(uint256 varg0) private { 
    require(varg0 != ~0, Panic(17));
    return 1 + varg0;
}

function () public payable { 
}

function update(address varg0) public nonPayable { 
    require(msg.data.length - 4 >= 32);
    require(varg0 == varg0);
    require(0x6162759edad730152f0df8115c698a42e666157f == msg.sender);
    _update = varg0;
    emit 0xed372f12d7a4444f7182316b3a21904ed182b1df492066f85a103c4087d59fcb(_update);
}

function 0xcc4(uint256 varg0, uint256 varg1, uint256 varg2, uint256 varg3) private { 
    require(0xba12222222228d8ba445958a75a0704d566bf2c8 == msg.sender, Error(0x6e6f000000000000000000000000000000000000000000000000000000000000));
    require(_fETH.code.size);
    v0, v1 = _fETH.getCash().gas(msg.gas);
    require(v0); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
    if (v1 > 0x16345785d8a0000) {
        v2 = 0x24e6();
        require(stor_1_0_19.code.size);
        v3, v4 = stor_1_0_19.transfer(address(v2), stor_2).gas(msg.gas);
        require(v3); // checks call status, propagates error data on error
        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
        require(v4 == v4);
        require(_comptroller.code.size);
        v5, v6 = _comptroller.cTokensByUnderlying(stor_1_0_19).gas(msg.gas);
        require(v5); // checks call status, propagates error data on error
        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
        require(v6 == address(v6));
        emit Log(address(v6), 1);
        v7 = new uint256[](1);
        CALLDATACOPY(v7.data, msg.data.length, 32);
        require(0 < v7.length, Panic(50));
        v8 = v7.data;
        v7[0] = address(v6);
        MEM[MEM[64]] = 0xbd5b853b00000000000000000000000000000000000000000000000000000000;
        v9 = new array[](v7.length);
        v10 = v11 = 0;
        v12 = v13 = v9.data;
        v14 = v15 = v7.data;
        while (v10 < v7.length) {
            MEM[v12] = address(MEM[v14]);
            v12 += 32;
            v14 += 32;
            v10 += 1;
        }
        require((address(v2)).code.size);
        v16 = address(v2).setup(v9).gas(msg.gas);
        require(v16); // checks call status, propagates error data on error
        MEM[MEM[64]] = 0x1249c58b00000000000000000000000000000000000000000000000000000000;
        require((address(v2)).code.size);
        v17 = address(v2).mint().gas(msg.gas);
        require(v17); // checks call status, propagates error data on error
        MEM[MEM[64]] = 0x5ec88c7900000000000000000000000000000000000000000000000000000000;
        require(_comptroller.code.size);
        v18, v19, v20, v21 = _comptroller.getAccountLiquidity(address(v2)).gas(msg.gas);
        require(v18); // checks call status, propagates error data on error
        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);
        require(_priceFeed.code.size);
        v22, v23 = _priceFeed.getUnderlyingPrice(_fETH).gas(msg.gas);
        require(v22); // checks call status, propagates error data on error
        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
        v24 = _SafeMul(0xde0b6b3a7640000, v20);
        require(v23, Panic(18));
        v25 = v26 = v24 / v23;
        require(_fETH.code.size);
        v27, v25 = _fETH.getCash().gas(msg.gas);
        require(v27); // checks call status, propagates error data on error
        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
        if (v26 <= v25) {
        }
        require((address(v2)).code.size);
        v28 = address(v2).borrow(v25).gas(msg.gas);
        require(v28); // checks call status, propagates error data on error
        require((address(v2)).code.size);
        v29 = address(v2).redeemAll().gas(msg.gas);
        require(v29); // checks call status, propagates error data on error
        goto 0x1051B0xcfa;
    }
    require(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.code.size);
    v30 = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(0xa968163f0a57b400000).gas(msg.gas);
    require(v30); // checks call status, propagates error data on error
    require(_fETH.code.size);
    v31 = _fETH.mint().value(0xa968163f0a57b400000).gas(msg.gas);
    require(v31); // checks call status, propagates error data on error
    v32 = new uint256[](1);
    if (1) {
        CALLDATACOPY(v32.data, msg.data.length, 32);
    }
    require(v32.length, Panic(50));
    v33 = v32.data;
    v32[0] = _fETH;
    MEM[MEM[64]] = 0xc299823800000000000000000000000000000000000000000000000000000000;
    v34 = new array[](v32.length);
    v35 = v36 = 0;
    v37 = v38 = v34.data;
    v39 = v40 = v32.data;
    while (v35 < v32.length) {
        MEM[v37] = address(MEM[v39]);
        v37 += 32;
        v39 += 32;
        v35 += 1;
    }
    require(_comptroller.code.size);
    v41, v42 = _comptroller.enterMarkets(v34).gas(msg.gas);
    require(v41); // checks call status, propagates error data on error
    RETURNDATACOPY(v42, 0, RETURNDATASIZE());
    MEM[64] = v42 + (~0x1f & RETURNDATASIZE() + 31);
    v43 = v44 = 0;
    require(v42 + RETURNDATASIZE() - v42 >= 32v44, v44);
    require(MEM[v42] <= 0xffffffffffffffffv44, v44);
    require(v42 + RETURNDATASIZE() > v42 + MEM[v42] + 31v44, v44);
    v45 = 0x2ebc(MEM[v42 + MEM[v42]]);
    require(!((MEM[64] + (~0x1f & v45 + 31) < MEM[64]) | (MEM[64] + (~0x1f & v45 + 31) > 0xffffffffffffffff)), Panic(65));
    MEM[64] = MEM[64] + (~0x1f & v45 + 31);
    MEM[MEM[64]] = MEM[v42 + MEM[v42]];
    v46 = v47 = MEM[64] + 32;
    v48 = v49 = 32 + (v42 + MEM[v42]);
    require(v42 + RETURNDATASIZE() >= 32 + (v42 + MEM[v42] + (MEM[v42 + MEM[v42]] << 5))v44, v44);
    while (v43 < MEM[v42 + MEM[v42]]) {
        MEM[v46] = MEM[v48];
        v43 += 1;
        v46 += 32;
        v48 += 32;
    }
    v50 = new uint256[](array_7.length);
    v51 = v52 = v50.data;
    if (array_7.length) {
        do {
            MEM[v51] = address(STORAGE[v53]);
            v53 = v53 + 1;
            v51 += 32;
        } while (v52 + (array_7.length << 5) <= v51);
    }
    v54 = new uint256[](array_8.length);
    v55 = v56 = v54.data;
    if (array_8.length) {
        do {
            MEM[v55] = address(STORAGE[v57]);
            v57 = v57 + 1;
            v55 += 32;
        } while (v56 + (array_8.length << 5) <= v55);
    }
    v58 = v59 = 0;
    while (v58 < v50.length) {
        if (_comptroller.code.size) {
            break;
        }
        require(_comptroller.code.size);
        v60, v61, v62, v63 = _comptroller.getAccountLiquidity(address(this)).gas(msg.gas);
        if (v60) {
            break;
        }
        require(v60); // checks call status, propagates error data on error
        if (MEM[64] + RETURNDATASIZE() - MEM[64] >= 96) {
            break;
        }
        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);
        require(v58 < v50.length, Panic(50));
        require(v58 < v54.length, Panic(50));
        v64 = v54[v58];
        require(_priceFeed.code.size);
        v65, v66 = _priceFeed.getUnderlyingPrice(address(v50[v58])).gas(msg.gas);
        require(v65); // checks call status, propagates error data on error
        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
        v67 = _SafeMul(0xde0b6b3a7640000, v62);
        require(v66, Panic(18));
        v68 = v69 = v67 / v66;
        require((address(v50[v58])).code.size);
        v70, v68 = address(v50[v58]).getCash().gas(msg.gas);
        require(v70); // checks call status, propagates error data on error
        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
        require(_comptroller.code.size);
        v71, v72 = _comptroller.borrowCaps(address(v50[v58])).gas(msg.gas);
        require(v71); // checks call status, propagates error data on error
        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
        if (v69 <= v68) {
        }
        if (v72) {
            require((address(v50[v58])).code.size);
            v73 = address(v50[v58]).totalBorrows().gas(msg.gas);
            require(v73); // checks call status, propagates error data on error
            require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
            v74 = _SafeSub(v72, MEM[MEM[64]]);
            if (v74 <= v68) {
                require(2, Panic(18));
                v68 = v75 = v74 >> 1;
            }
        }
        MEM[MEM[64]] = 0xc5ebeaec00000000000000000000000000000000000000000000000000000000;
        MEM[4 + MEM[64]] = v68;
        require((address(v50[v58])).code.size);
        v76 = address(v50[v58]).call(MEM[(MEM[64]) len (36 + MEM[64] - MEM[64])], MEM[(MEM[64]) len 32]).gas(msg.gas);
        require(v76); // checks call status, propagates error data on error
        MEM[64] = MEM[64] + (RETURNDATASIZE() + 31 & ~0x1f);
        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
        v58 = 0x2f8a(v58);
    }
    v77 = 0x24e6();
    require(stor_1_0_19.code.size);
    v78, v79 = stor_1_0_19.balanceOf(address(this)).gas(msg.gas);
    require(v78); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
    emit Log(3, v79);
    require(stor_1_0_19.code.size);
    v80, v81 = stor_1_0_19.transfer(address(v77), stor_2).gas(msg.gas);
    require(v80); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
    require(v81 == v81);
    require(_comptroller.code.size);
    v82, v83 = _comptroller.cTokensByUnderlying(stor_1_0_19).gas(msg.gas);
    require(v82); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
    require(v83 == address(v83));
    v84 = new uint256[](1);
    CALLDATACOPY(v84.data, msg.data.length, 32);
    require(0 < v84.length, Panic(50));
    v85 = v84.data;
    v84[0] = address(v83);
    MEM[MEM[64]] = 0xbd5b853b00000000000000000000000000000000000000000000000000000000;
    v86 = new array[](v84.length);
    v87 = v88 = 0;
    v89 = v90 = v86.data;
    v91 = v92 = v84.data;
    while (v87 < v84.length) {
        MEM[v89] = address(MEM[v91]);
        v89 += 32;
        v91 += 32;
        v87 += 1;
    }
    require((address(v77)).code.size);
    v93 = address(v77).setup(v86).gas(msg.gas);
    require(v93); // checks call status, propagates error data on error
    MEM[MEM[64]] = 0x1249c58b00000000000000000000000000000000000000000000000000000000;
    require((address(v77)).code.size);
    v94 = address(v77).mint().gas(msg.gas);
    require(v94); // checks call status, propagates error data on error
    MEM[MEM[64]] = 0x5ec88c7900000000000000000000000000000000000000000000000000000000;
    require(_comptroller.code.size);
    v95, v96, v97, v98 = _comptroller.getAccountLiquidity(address(v77)).gas(msg.gas);
    require(v95); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);
    require(_priceFeed.code.size);
    v99, v100 = _priceFeed.getUnderlyingPrice(_fETH).gas(msg.gas);
    require(v99); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
    v101 = _SafeMul(0xde0b6b3a7640000, v97);
    require(v100, Panic(18));
    v102 = v103 = v101 / v100;
    require(_fETH.code.size);
    v104, v102 = _fETH.getCash().gas(msg.gas);
    require(v104); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
    if (v103 <= v102) {
    }
    require((address(v77)).code.size);
    v105 = address(v77).borrow(v102).gas(msg.gas);
    require(v105); // checks call status, propagates error data on error
    require((address(v77)).code.size);
    v106 = address(v77).redeemAll().gas(msg.gas);
    require(v106); // checks call status, propagates error data on error
    require(_comptroller.code.size);
    v107, v108, v109, v110 = _comptroller.getAccountLiquidity(address(this)).gas(msg.gas);
    require(v107); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 96);
    require(_fETH.code.size);
    v111, v112 = _fETH.getCash().gas(msg.gas);
    require(v111); // checks call status, propagates error data on error
    require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
    v113 = v114 = v109 > 0;
    if (v114) {
        v113 = v112 > 0;
    }
    if (v113) {
        require(_fETH.code.size);
        v115, v116 = _fETH.redeemUnderlying(v112).gas(msg.gas);
        require(v115); // checks call status, propagates error data on error
        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
        require(!v116, Error(0x6661696c00000000000000000000000000000000000000000000000000000000));
        goto 0xd04;
    }
    require(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.code.size);
    v117 = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.deposit().value(0xa968163f0a57b400000).gas(msg.gas);
    require(v117); // checks call status, propagates error data on error
    0xfe8(0xa968163f0a57b400000, 0xba12222222228d8ba445958a75a0704d566bf2c8, 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2);
    0xfe8(stor_2, 0xba12222222228d8ba445958a75a0704d566bf2c8, stor_1_0_19);
    if (this.balance > 0x16345785d8a0000) {
        v118 = _SafeSub(this.balance, 0x16345785d8a0000);
        v119 = _update.call().value(v118).gas(2300 * !v118);
        require(v119); // checks call status, propagates error data on error
    }
    v120 = new uint256[](array_8.length);
    v121 = v122 = v120.data;
    if (array_8.length) {
        do {
            MEM[v121] = address(STORAGE[v123]);
            v123 = v123 + 1;
            v121 += 32;
        } while (v122 + (array_8.length << 5) <= v121);
    }
    v124 = v125 = 0;
    while (v124 < v120.length) {
        if (v124 < v120.length) {
            break;
        }
        require(v124 < v120.length, Panic(50));
        if ((address(v120[v124])).code.size) {
            break;
        }
        require((address(v120[v124])).code.size);
        v126, v127 = address(v120[v124]).balanceOf(address(this)).gas(msg.gas);
        if (v126) {
            break;
        }
        require(v126); // checks call status, propagates error data on error
        if (MEM[64] + RETURNDATASIZE() - MEM[64] >= 32) {
            break;
        }
        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
        if (!v127) {
            break;
        }
        if (v127) {
            require(v124 < v120.length, Panic(50));
            if (this.balance >= 0) {
                if ((address(v120[v124])).code.size) {
                    v128 = v129 = 0;
                    while (v128 < 68) {
                        MEM[v128 + MEM[64]] = MEM[v128 + (MEM[64] + 32)];
                        v128 += 32;
                    }
                    if (v128 > 68) {
                        MEM[68 + MEM[64]] = 0;
                        goto 0x2c22B0x25b4B0x24cdB0x1242B0x100a0xcc4;
                    }
                    v130, v131, v132, v133 = address(v120[v124]).transfer(_update, v127).gas(msg.gas);
                    if (RETURNDATASIZE() == 0) {
                        v134 = v135 = 96;
                    } else {
                        v134 = v136 = new bytes[](RETURNDATASIZE());
                        RETURNDATACOPY(v136.data, 0, RETURNDATASIZE());
                    }
                    if (!v130) {
                        require(!MEM[v134]v133, MEM[v134]);
                        v137 = new array[](v138.length);
                        v139 = v140 = 0;
                        while (v139 < v138.length) {
                            v137[v139] = v138[v139];
                            v139 += 32;
                        }
                        if (v139 > v138.length) {
                            v137[32] = 0;
                            goto 0x2bd8B0x265bB0x2616B0x24cdB0x1242B0x100a0xcc4;
                        }
                        revert(Error(v137, v141, 'SafeERC20: low-level call failed'));
                    } else {
                        if (MEM[v134]) {
                            require(32 + v134 + MEM[v134] - (32 + v134) >= 32);
                            require(MEM[32 + v134] == MEM[32 + v134]);
                            require(MEM[32 + v134], Error('SafeERC20: ERC20 operation did not succeed'));
                        }
                        return v127, v124, v120, this.balance;
                    }
                } else {
                    MEM[4 + MEM[64]] = 32;
                }
            } else {
                MEM[4 + MEM[64]] = 32;
            }
            revert(Error('Address: call to non-contract'));
        }
        v124 = 0x2f8a(v124);
    }
    return ;
}

function claim(address varg0) public nonPayable { 
    require(msg.data.length - 4 >= 32);
    require(varg0 == varg0);
    require(0x6162759edad730152f0df8115c698a42e666157f == msg.sender);
    if (0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2 != varg0) {
        require(varg0.code.size);
        v0, v1 = varg0.balanceOf(address(this)).gas(msg.gas);
        require(v0); // checks call status, propagates error data on error
        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
        0xfe8(v1, msg.sender, varg0);
    } else {
        require(varg0.code.size);
        v2, v3 = varg0.balanceOf(address(this)).gas(msg.gas);
        require(v2); // checks call status, propagates error data on error
        require(MEM[64] + RETURNDATASIZE() - MEM[64] >= 32);
        require(0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.code.size);
        v4 = 0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2.withdraw(v3).gas(msg.gas);
        require(v4); // checks call status, propagates error data on error
        v5 = msg.sender.call().value(this.balance).gas(2300 * !this.balance);
        require(v5); // checks call status, propagates error data on error
    }
}

function index() public nonPayable { 
    return _index;
}

function 0xfe8(uint256 varg0, uint256 varg1, uint256 varg2) private { 
    v0 = address(varg1);
    v1 = address(varg2);
    if (this.balance >= 0) {
        if (v1.code.size) {
            v2 = v3 = 0;
            while (v2 < 68) {
                MEM[v2 + MEM[64]] = MEM[v2 + (MEM[64] + 32)];
                v2 += 32;
            }
            if (v2 > 68) {
                MEM[68 + MEM[64]] = 0;
                goto 0x2c22B0x25b4B0x24cdB0x1242B0x100a0xfe8;
            }
            v4, v5, v6, v7 = address(v1).transfer(v0, varg0).gas(msg.gas);
            if (RETURNDATASIZE() == 0) {
                v8 = v9 = 96;
            } else {
                v8 = v10 = new bytes[](RETURNDATASIZE());
                RETURNDATACOPY(v10.data, 0, RETURNDATASIZE());
            }
            if (!v4) {
                require(!MEM[v8]v7, MEM[v8]);
                v11 = new array[](v12.length);
                v13 = v14 = 0;
                while (v13 < v12.length) {
                    v11[v13] = v12[v13];
                    v13 += 32;
                }
                if (v13 > v12.length) {
                    v11[32] = 0;
                    goto 0x2bd8B0x265bB0x2616B0x24cdB0x1242B0x100a0xfe8;
                }
                revert(Error(v11, v15, 'SafeERC20: low-level call failed'));
            } else {
                if (MEM[v8]) {
                    require(32 + v8 + MEM[v8] - (32 + v8) >= 32);
                    require(MEM[32 + v8] == MEM[32 + v8]);
                    require(MEM[32 + v8], Error('SafeERC20: ERC20 operation did not succeed'));
                }
                return ;
            }
        } else {
            MEM[4 + MEM[64]] = 32;
        }
    } else {
        MEM[4 + MEM[64]] = 32;
    }
    revert(Error('Address: call to non-contract'));
}

// Note: The function selector is not present in the original solidity code.
// However, we display it for the sake of completeness.

function __function_selector__(bytes4 function_selector) public payable { 
    MEM[64] = 128;
    if (msg.data.length < 4) {
        require(!msg.data.length);
        ();
    } else if (0x5fe3b567 > function_selector >> 224) {
        if (0x1c1b8772 == function_selector >> 224) {
            update(address);
        } else if (0x1e83409a == function_selector >> 224) {
            claim(address);
        } else if (0x2986c0e5 == function_selector >> 224) {
            index();
        } else if (0x34930754 == function_selector >> 224) {
            0x34930754();
        } else {
            require(0x349b4736 == function_selector >> 224);
            0x349b4736();
        }
    } else if (0x5fe3b567 == function_selector >> 224) {
        comptroller();
    } else if (0x741bef1a == function_selector >> 224) {
        priceFeed();
    } else if (0xbe6002c2 == function_selector >> 224) {
        exec(address,bytes);
    } else if (0xcc14d688 == function_selector >> 224) {
        fETH();
    } else {
        require(0xf04f2707 == function_selector >> 224);
        receiveFlashLoan(address[],uint256[],uint256[],bytes);
    }
}
